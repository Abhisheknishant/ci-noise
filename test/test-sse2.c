/* Copyright (c) 2017 Evan Nemerson <evan@nemerson.com>
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without
 * restriction, including without limitation the rights to use, copy,
 * modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
 * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

#include "test.h"
#include "../sse2.h"

#include <stdio.h>

#define assert_m128i_epi8(a, cmp, b)					\
  do {									\
    munit_assert_int8(((int8_t*) (&a))[ 0], cmp, ((int8_t*) (&b))[ 0]);	\
    munit_assert_int8(((int8_t*) (&a))[ 1], cmp, ((int8_t*) (&b))[ 1]);	\
    munit_assert_int8(((int8_t*) (&a))[ 2], cmp, ((int8_t*) (&b))[ 2]);	\
    munit_assert_int8(((int8_t*) (&a))[ 3], cmp, ((int8_t*) (&b))[ 3]);	\
    munit_assert_int8(((int8_t*) (&a))[ 4], cmp, ((int8_t*) (&b))[ 4]);	\
    munit_assert_int8(((int8_t*) (&a))[ 5], cmp, ((int8_t*) (&b))[ 5]);	\
    munit_assert_int8(((int8_t*) (&a))[ 6], cmp, ((int8_t*) (&b))[ 6]);	\
    munit_assert_int8(((int8_t*) (&a))[ 7], cmp, ((int8_t*) (&b))[ 7]);	\
    munit_assert_int8(((int8_t*) (&a))[ 8], cmp, ((int8_t*) (&b))[ 8]);	\
    munit_assert_int8(((int8_t*) (&a))[ 9], cmp, ((int8_t*) (&b))[ 9]);	\
    munit_assert_int8(((int8_t*) (&a))[10], cmp, ((int8_t*) (&b))[10]);	\
    munit_assert_int8(((int8_t*) (&a))[11], cmp, ((int8_t*) (&b))[11]);	\
    munit_assert_int8(((int8_t*) (&a))[12], cmp, ((int8_t*) (&b))[12]);	\
    munit_assert_int8(((int8_t*) (&a))[13], cmp, ((int8_t*) (&b))[13]);	\
    munit_assert_int8(((int8_t*) (&a))[14], cmp, ((int8_t*) (&b))[14]);	\
    munit_assert_int8(((int8_t*) (&a))[15], cmp, ((int8_t*) (&b))[15]);	\
  } while (0)

#define assert_m128i_epi16(a, cmp, b)					\
  do {									\
    munit_assert_int16(((int16_t*) (&a))[ 0], cmp, ((int16_t*) (&b))[ 0]);	\
    munit_assert_int16(((int16_t*) (&a))[ 1], cmp, ((int16_t*) (&b))[ 1]);	\
    munit_assert_int16(((int16_t*) (&a))[ 2], cmp, ((int16_t*) (&b))[ 2]);	\
    munit_assert_int16(((int16_t*) (&a))[ 3], cmp, ((int16_t*) (&b))[ 3]);	\
    munit_assert_int16(((int16_t*) (&a))[ 4], cmp, ((int16_t*) (&b))[ 4]);	\
    munit_assert_int16(((int16_t*) (&a))[ 5], cmp, ((int16_t*) (&b))[ 5]);	\
    munit_assert_int16(((int16_t*) (&a))[ 6], cmp, ((int16_t*) (&b))[ 6]);	\
    munit_assert_int16(((int16_t*) (&a))[ 7], cmp, ((int16_t*) (&b))[ 7]);	\
  } while (0)

static MunitResult
test_simde_mm_add_epi8(const MunitParameter params[], void* data) {
  (void) params;
  (void) data;

  const struct {
    simde__m128i a;
    simde__m128i b;
    simde__m128i r;
  } test_vec[8] = {
    { simde_mm_set_epi8(0x38, 0x70, 0xd8, 0x83, 0x2b, 0x0d, 0xc8, 0x0e,
			0x59, 0xc5, 0x29, 0x93, 0xf8, 0x91, 0x24, 0x5c),
      simde_mm_set_epi8(0xf7, 0xae, 0xd8, 0x72, 0x43, 0xc2, 0xa3, 0xad,
			0xaf, 0x39, 0xbf, 0x20, 0x01, 0x44, 0x1d, 0x37),
      simde_mm_set_epi8(0x2f, 0x1e, 0xb0, 0xf5, 0x6e, 0xcf, 0x6b, 0xbb,
			0x08, 0xfe, 0xe8, 0xb3, 0xf9, 0xd5, 0x41, 0x93) },
    { simde_mm_set_epi8(0x94, 0x89, 0xfb, 0x0a, 0x1a, 0xb2, 0xe5, 0x8f,
			0xfe, 0xc5, 0x90, 0x45, 0x74, 0xf5, 0x58, 0x6b),
      simde_mm_set_epi8(0xaf, 0xa6, 0x18, 0xae, 0x73, 0x15, 0x76, 0xfd,
			0x75, 0x66, 0xb8, 0x3c, 0x83, 0x9f, 0x0b, 0xe7),
      simde_mm_set_epi8(0x43, 0x2f, 0x13, 0xb8, 0x8d, 0xc7, 0x5b, 0x8c,
			0x73, 0x2b, 0x48, 0x81, 0xf7, 0x94, 0x63, 0x52) },
    { simde_mm_set_epi8(0xb6, 0x3a, 0x7d, 0x4e, 0xc0, 0xb0, 0x5b, 0x39,
			0xa4, 0x2b, 0xac, 0x0e, 0x77, 0xa3, 0xca, 0x3e),
      simde_mm_set_epi8(0x7f, 0x82, 0x01, 0x7d, 0xde, 0xa2, 0x79, 0x1c,
			0x35, 0x55, 0x53, 0x79, 0xf4, 0x8f, 0x7f, 0x51),
      simde_mm_set_epi8(0x35, 0xbc, 0x7e, 0xcb, 0x9e, 0x52, 0xd4, 0x55,
			0xd9, 0x80, 0xff, 0x87, 0x6b, 0x32, 0x49, 0x8f) },
    { simde_mm_set_epi8(0x1f, 0xe1, 0x17, 0x2f, 0x13, 0x9f, 0xb0, 0x85,
			0xf7, 0xca, 0x31, 0xaa, 0xf3, 0x99, 0xa8, 0x60),
      simde_mm_set_epi8(0x73, 0x1e, 0x9a, 0xdf, 0xc0, 0x9d, 0x2d, 0x8d,
			0x56, 0xa7, 0xca, 0xa1, 0x80, 0x0e, 0x8f, 0x3b),
      simde_mm_set_epi8(0x92, 0xff, 0xb1, 0x0e, 0xd3, 0x3c, 0xdd, 0x12,
			0x4d, 0x71, 0xfb, 0x4b, 0x73, 0xa7, 0x37, 0x9b) },
    { simde_mm_set_epi8(0x85, 0x9c, 0xe7, 0x43, 0x6f, 0x7f, 0x1a, 0x80,
			0xce, 0x88, 0x1d, 0x46, 0x44, 0x73, 0xe1, 0xd7),
      simde_mm_set_epi8(0x6a, 0x5e, 0x79, 0xca, 0x60, 0xd5, 0xd0, 0xcd,
			0x9f, 0x0f, 0xc2, 0xcc, 0xcd, 0x00, 0x97, 0x37),
      simde_mm_set_epi8(0xef, 0xfa, 0x60, 0x0d, 0xcf, 0x54, 0xea, 0x4d,
			0x6d, 0x97, 0xdf, 0x12, 0x11, 0x73, 0x78, 0x0e) },
    { simde_mm_set_epi8(0x9d, 0xec, 0x07, 0x00, 0x3a, 0xdc, 0xfb, 0xcc,
			0xf3, 0x36, 0xe5, 0x07, 0xc3, 0xe6, 0xa1, 0x17),
      simde_mm_set_epi8(0x2d, 0xbe, 0x44, 0x1c, 0xec, 0xfd, 0x3d, 0x97,
			0x5d, 0x5b, 0x85, 0xbe, 0x27, 0x35, 0x8d, 0x1f),
      simde_mm_set_epi8(0xca, 0xaa, 0x4b, 0x1c, 0x26, 0xd9, 0x38, 0x63,
			0x50, 0x91, 0x6a, 0xc5, 0xea, 0x1b, 0x2e, 0x36) },
    { simde_mm_set_epi8(0x31, 0x8b, 0xcc, 0x7e, 0x91, 0x8a, 0x17, 0xab,
			0xd8, 0xa1, 0xe6, 0xa9, 0x39, 0x8b, 0x4d, 0x20),
      simde_mm_set_epi8(0xf8, 0x50, 0x4f, 0xcf, 0x7c, 0x59, 0x25, 0x48,
			0x04, 0x09, 0x37, 0xe4, 0x91, 0x2f, 0x4d, 0x72),
      simde_mm_set_epi8(0x29, 0xdb, 0x1b, 0x4d, 0x0d, 0xe3, 0x3c, 0xf3,
			0xdc, 0xaa, 0x1d, 0x8d, 0xca, 0xba, 0x9a, 0x92) },
    { simde_mm_set_epi8(0xff, 0xfb, 0xc0, 0xae, 0xb9, 0x1e, 0x09, 0xe6,
			0xa1, 0x01, 0xf4, 0xe4, 0x07, 0xed, 0x37, 0x76),
      simde_mm_set_epi8(0x17, 0x64, 0x65, 0xca, 0xb9, 0xaf, 0xdd, 0xf8,
			0xc9, 0x16, 0x4a, 0x1c, 0x09, 0x20, 0x3d, 0x38),
      simde_mm_set_epi8(0x16, 0x5f, 0x25, 0x78, 0x72, 0xcd, 0xe6, 0xde,
			0x6a, 0x17, 0x3e, 0x00, 0x10, 0x0d, 0x74, 0xae) }
  };

  for (size_t i = 0 ; i < (sizeof(test_vec) / sizeof(test_vec[0])); i++) {
    simde__m128i r = simde_mm_add_epi8(test_vec[i].a, test_vec[i].b);
    assert_m128i_epi8(r, ==, test_vec[i].r);
  }

  return MUNIT_OK;
}

static MunitResult
test_simde_mm_andnot_si128(const MunitParameter params[], void* data) {
  (void) params;
  (void) data;

  const struct {
    simde__m128i a;
    simde__m128i b;
    simde__m128i r;
  } test_vec[8] = {
    { simde_mm_set_epi32(0x6f0aeb5b, 0xa01e005a, 0xd46ef1ec, 0x8b5c329a),
      simde_mm_set_epi32(0x3dbb1950, 0x30d5ae0d, 0x4ce4bd25, 0xae876254),
      simde_mm_set_epi32(0x804404a4, 0x4f2051a0, 0x23110212, 0x50208d21) },
    { simde_mm_set_epi32(0x6d78b3b2, 0x8ebf67c3, 0x36b4d823, 0xe3be5a93),
      simde_mm_set_epi32(0x9ae06454, 0x5e9403ba, 0x3c6d6573, 0xe2fd54c4),
      simde_mm_set_epi32(0x00070809, 0x21409804, 0xc102028c, 0x1c00a128) },
    { simde_mm_set_epi32(0xb6a3fc8d, 0xa81c50d7, 0xd863c415, 0x591aff62),
      simde_mm_set_epi32(0x0c8efc27, 0xc3604c96, 0x1314e613, 0x697bb87c),
      simde_mm_set_epi32(0x41500350, 0x1483a328, 0x248819e8, 0x86840081) },
    { simde_mm_set_epi32(0x00706fb2, 0x0df02aba, 0xf2e4e9d5, 0xd579c204),
      simde_mm_set_epi32(0xed1e4391, 0x92f4722b, 0x14f0caee, 0xfb8cd992),
      simde_mm_set_epi32(0x1281904c, 0x600b8544, 0x090b1400, 0x00022469) },
    { simde_mm_set_epi32(0x4d665a41, 0xd42ead4a, 0x1345147c, 0x0c7fab52),
      simde_mm_set_epi32(0x8b8e9f5a, 0x0e4cc80e, 0xb0c7292e, 0xd0340fc6),
      simde_mm_set_epi32(0x301120a4, 0x219112b1, 0x4c38c281, 0x23805029) },
    { simde_mm_set_epi32(0xf7d71d1a, 0xff075121, 0x71ca7076, 0xeb16e037),
      simde_mm_set_epi32(0xcdbfe594, 0x9fe3feaf, 0x6e4ec6c8, 0xe042c7bf),
      simde_mm_set_epi32(0x00000261, 0x00180050, 0x80310901, 0x14a91840) },
    { simde_mm_set_epi32(0x42b240f5, 0xc387a2ca, 0xe39aeb77, 0x58b2d1cd),
      simde_mm_set_epi32(0x60a9352f, 0xcc896048, 0x5b2a6a1b, 0xef74d67c),
      simde_mm_set_epi32(0x9d448a00, 0x30701d35, 0x04451480, 0x00092802) },
    { simde_mm_set_epi32(0xf1e3f9b0, 0xa851d722, 0x26ad66b1, 0x8a2da772),
      simde_mm_set_epi32(0xdf19fc12, 0x4df6a108, 0x6d3fd5ef, 0xc89414b3),
      simde_mm_set_epi32(0x0004024d, 0x120808d5, 0x90400800, 0x3542480c) }
  };

  for (size_t i = 0 ; i < (sizeof(test_vec) / sizeof(test_vec[0])); i++) {
    simde__m128i r = simde_mm_andnot_si128(test_vec[i].a, test_vec[i].b);
    assert_m128i_epi8(r, ==, test_vec[i].r);
  }

  return MUNIT_OK;
}

static MunitResult
test_simde_mm_and_si128(const MunitParameter params[], void* data) {
  (void) params;
  (void) data;

  const struct {
    simde__m128i a;
    simde__m128i b;
    simde__m128i r;
  } test_vec[8] = {
    { simde_mm_set_epi32(0x4d1de913, 0x8947413c, 0xcc753883, 0xfd94e470),
      simde_mm_set_epi32(0x62d23c00, 0xa521bec5, 0x633e05ac, 0x26794dac),
      simde_mm_set_epi32(0x22c21400, 0x2420bec1, 0x230a052c, 0x0269098c) },
    { simde_mm_set_epi32(0x751e20fe, 0x766bda1e, 0x53bc09ff, 0x12c02b7d),
      simde_mm_set_epi32(0x1df0be6c, 0xb3cfaceb, 0x50784474, 0xd6686c03),
      simde_mm_set_epi32(0x08e09e00, 0x818424e1, 0x00404400, 0xc4284402) },
    { simde_mm_set_epi32(0x96f7e77d, 0x9a4676db, 0x92847e73, 0xb9e13545),
      simde_mm_set_epi32(0x87fa3342, 0x33459e23, 0x8fefddef, 0x57a5e938),
      simde_mm_set_epi32(0x01081002, 0x21018820, 0x0d6b818c, 0x4604c838) },
    { simde_mm_set_epi32(0x04136724, 0x75b8d81a, 0x8f70d6d2, 0xac5ed66d),
      simde_mm_set_epi32(0x1ff06720, 0xdc692751, 0x126762bc, 0xda787c0a),
      simde_mm_set_epi32(0x1be00000, 0x88412741, 0x1007202c, 0x52202802) },
    { simde_mm_set_epi32(0xdd9354db, 0x8496db13, 0x3968e825, 0xe4058b52),
      simde_mm_set_epi32(0x3de9f766, 0x2ec34665, 0x9df67e3d, 0xad826dde),
      simde_mm_set_epi32(0x2068a324, 0x2a410464, 0x84961618, 0x0982648c) },
    { simde_mm_set_epi32(0xb8726376, 0x8a96fb60, 0xb62a165c, 0x67e573c8),
      simde_mm_set_epi32(0x8c2d1d06, 0x36d3d338, 0x61a95d2d, 0x3ed81cda),
      simde_mm_set_epi32(0x040d1c00, 0x34410018, 0x41814921, 0x18180c12) },
    { simde_mm_set_epi32(0x8a40deb7, 0xf6b3f9e9, 0xb27d6e93, 0xaac1e21d),
      simde_mm_set_epi32(0x01bd4d6b, 0x49017412, 0x6ad2e824, 0x4189bb17),
      simde_mm_set_epi32(0x01bd0148, 0x09000412, 0x48828024, 0x41081902) },
    { simde_mm_set_epi32(0x21c3b374, 0x7e3dddb5, 0x6825a4f2, 0x0326ce3f),
      simde_mm_set_epi32(0x7fdc9167, 0x44ef256b, 0xd1e4ff4c, 0xaeba15d4),
      simde_mm_set_epi32(0x5e1c0003, 0x00c2204a, 0x91c05b0c, 0xac9811c0) }
  };

  for (size_t i = 0 ; i < (sizeof(test_vec) / sizeof(test_vec[0])); i++) {
    simde__m128i r = simde_mm_and_si128(test_vec[i].a, test_vec[i].b);
    assert_m128i_epi8(r, ==, test_vec[i].r);
  }

  return MUNIT_OK;
}

static MunitResult
test_simde_mm_cmpeq_epi8(const MunitParameter params[], void* data) {
  (void) params;
  (void) data;

  const struct {
    simde__m128i a;
    simde__m128i b;
    simde__m128i r;
  } test_vec[8] = {
    { simde_mm_set_epi8(0xa8, 0x66, 0xdb, 0x50, 0x91, 0xe0, 0xea, 0xfb,
			0x6c, 0xd9, 0xcf, 0xf5, 0x47, 0x01, 0x44, 0x58),
      simde_mm_set_epi8(0xbe, 0xeb, 0xaa, 0x50, 0xbc, 0xc5, 0x0e, 0xfb,
			0x5e, 0x81, 0xcf, 0x89, 0x4d, 0x01, 0x44, 0x58),
      simde_mm_set_epi8(0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff,
			0x00, 0x00, 0xff, 0x00, 0x00, 0xff, 0xff, 0xff) },
    { simde_mm_set_epi8(0x51, 0x41, 0x82, 0x84, 0xaa, 0x10, 0xc5, 0xda,
			0x71, 0x66, 0x1a, 0xd6, 0x4e, 0x01, 0xbd, 0xa3),
      simde_mm_set_epi8(0x51, 0x41, 0xb9, 0x84, 0x72, 0x10, 0x5e, 0x37,
			0x71, 0x66, 0xf7, 0xa2, 0xe6, 0xa6, 0xdb, 0xe0),
      simde_mm_set_epi8(0xff, 0xff, 0x00, 0xff, 0x00, 0xff, 0x00, 0x00,
			0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00) },
    { simde_mm_set_epi8(0x3f, 0xc9, 0x9a, 0x51, 0x9c, 0xc6, 0xb7, 0xda,
			0x99, 0xb2, 0x5b, 0xf0, 0xdf, 0xd7, 0x5a, 0xb0),
      simde_mm_set_epi8(0x3f, 0xc9, 0xd7, 0xb3, 0x9c, 0xc6, 0xb7, 0x60,
			0x46, 0xb2, 0x60, 0xf0, 0x81, 0xd7, 0x9f, 0xf5),
      simde_mm_set_epi8(0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0xff, 0x00,
			0x00, 0xff, 0x00, 0xff, 0x00, 0xff, 0x00, 0x00) },
    { simde_mm_set_epi8(0xb9, 0xf6, 0xd0, 0xdb, 0x69, 0x32, 0x0d, 0xed,
			0xaa, 0x96, 0x56, 0xc4, 0x3f, 0x89, 0x6f, 0xfe),
      simde_mm_set_epi8(0x94, 0xf6, 0xd0, 0xdb, 0xbc, 0x34, 0x5c, 0x04,
			0xce, 0x96, 0xec, 0x56, 0x3f, 0x89, 0x6f, 0xfe),
      simde_mm_set_epi8(0x00, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00,
			0x00, 0xff, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff) },
    { simde_mm_set_epi8(0xc7, 0x3e, 0x28, 0x67, 0x32, 0x9b, 0x4b, 0xed,
			0xd4, 0x75, 0xae, 0x24, 0x39, 0xeb, 0xed, 0xbd),
      simde_mm_set_epi8(0x10, 0x3e, 0x28, 0xb8, 0x32, 0x9b, 0x4b, 0xed,
			0xe7, 0x75, 0xae, 0xaf, 0xa8, 0xeb, 0x50, 0xbd),
      simde_mm_set_epi8(0x00, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0xff,
			0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0x00, 0xff) },
    { simde_mm_set_epi8(0xd6, 0xf5, 0x60, 0x05, 0xfa, 0x9e, 0x78, 0x9d,
			0x27, 0x54, 0xa9, 0xeb, 0xf8, 0xe3, 0xfe, 0xd1),
      simde_mm_set_epi8(0x76, 0xf5, 0x60, 0x05, 0xfa, 0x9e, 0x0e, 0x9d,
			0x1e, 0xb9, 0xe2, 0xae, 0xf8, 0x1d, 0xfe, 0xd1),
      simde_mm_set_epi8(0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0xff,
			0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0xff, 0xff) },
    { simde_mm_set_epi8(0x1c, 0xad, 0x5b, 0x5b, 0x5c, 0xfb, 0x9c, 0x0e,
			0x09, 0x8a, 0x71, 0xb9, 0x31, 0x0e, 0x53, 0xed),
      simde_mm_set_epi8(0x1c, 0xad, 0x5b, 0x5b, 0x4d, 0x9c, 0x87, 0xbc,
			0x69, 0x8a, 0x71, 0x63, 0x31, 0x0e, 0xd4, 0xed),
      simde_mm_set_epi8(0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00,
			0x00, 0xff, 0xff, 0x00, 0xff, 0xff, 0x00, 0xff) },
    { simde_mm_set_epi8(0xa5, 0xcd, 0xf3, 0x32, 0x91, 0x67, 0xc4, 0x35,
			0x05, 0xdd, 0xdd, 0x90, 0x83, 0x94, 0x0e, 0x27),
      simde_mm_set_epi8(0xa3, 0xcd, 0xd0, 0x32, 0xec, 0x67, 0xc4, 0x54,
			0x3e, 0xdd, 0xdd, 0xa3, 0xef, 0x94, 0x0e, 0x01),
      simde_mm_set_epi8(0x00, 0xff, 0x00, 0xff, 0x00, 0xff, 0xff, 0x00,
			0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00) }
  };

  for (size_t i = 0 ; i < (sizeof(test_vec) / sizeof(test_vec[0])); i++) {
    simde__m128i r = simde_mm_cmpeq_epi8(test_vec[i].a, test_vec[i].b);
    assert_m128i_epi8(r, ==, test_vec[i].r);
  }

  return MUNIT_OK;
}

static MunitResult
test_simde_mm_cmplt_epi8(const MunitParameter params[], void* data) {
  (void) params;
  (void) data;

  const struct {
    simde__m128i a;
    simde__m128i b;
    simde__m128i r;
  } test_vec[8] = {
    { simde_mm_set_epi8(0xac, 0x9c, 0x47, 0x0a, 0xe2, 0xb1, 0x5f, 0x21,
			0x4a, 0x48, 0xcc, 0x61, 0xdb, 0x3a, 0xb3, 0xc5),
      simde_mm_set_epi8(0x4c, 0xe4, 0x47, 0x0a, 0x0e, 0xb1, 0x5f, 0x21,
			0xfe, 0x9b, 0xb9, 0xb2, 0x49, 0x89, 0xb3, 0x24),
      simde_mm_set_epi8(0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0xff, 0xff, 0x00, 0xff, 0x00, 0xff, 0x00, 0x00) },
    { simde_mm_set_epi8(0x99, 0x0d, 0x55, 0xaa, 0x65, 0x2d, 0xd8, 0x47,
			0x47, 0xdf, 0x11, 0x2e, 0xe0, 0x49, 0x89, 0xcc),
      simde_mm_set_epi8(0x99, 0x0d, 0x1d, 0x34, 0x65, 0x96, 0xd8, 0x19,
			0x47, 0xdf, 0x11, 0xd0, 0xa7, 0xc1, 0x0c, 0xcc),
      simde_mm_set_epi8(0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00,
			0x00, 0x00, 0x00, 0xff, 0x00, 0xff, 0x00, 0x00) },
    { simde_mm_set_epi8(0x1d, 0x78, 0x3f, 0xd5, 0x6a, 0x7d, 0x7a, 0xd9,
			0x67, 0x7f, 0xc2, 0x12, 0x54, 0x66, 0xa4, 0x0b),
      simde_mm_set_epi8(0x1d, 0x78, 0x3f, 0x2b, 0x11, 0x49, 0x21, 0x22,
			0x94, 0x7f, 0x49, 0x12, 0x54, 0x66, 0xa4, 0x0b),
      simde_mm_set_epi8(0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00) },
    { simde_mm_set_epi8(0x45, 0x09, 0xea, 0x92, 0x3c, 0x50, 0xfd, 0x56,
			0x02, 0x73, 0x53, 0x05, 0x52, 0x2a, 0xf3, 0x63),
      simde_mm_set_epi8(0x3a, 0xea, 0x16, 0x92, 0x3c, 0x50, 0xfd, 0x56,
			0x73, 0x73, 0x53, 0x05, 0x52, 0x2a, 0xf3, 0x10),
      simde_mm_set_epi8(0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00) },
    { simde_mm_set_epi8(0x73, 0x88, 0x40, 0x9f, 0x34, 0x1c, 0x3b, 0x26,
			0x35, 0x15, 0x53, 0xfb, 0x06, 0x1a, 0xcb, 0x01),
      simde_mm_set_epi8(0x73, 0x88, 0xa8, 0x35, 0x34, 0x1c, 0x3b, 0x89,
			0x6a, 0x15, 0x53, 0x25, 0xf4, 0x1a, 0x36, 0x01),
      simde_mm_set_epi8(0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0xff,
			0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00) },
    { simde_mm_set_epi8(0xf2, 0xac, 0x98, 0x13, 0x6b, 0xb0, 0x34, 0x61,
			0xd9, 0x1a, 0xe9, 0x7f, 0xcb, 0x03, 0x5c, 0xf0),
      simde_mm_set_epi8(0xf2, 0x57, 0x98, 0x13, 0x6b, 0xb0, 0x34, 0x84,
			0xd9, 0x7d, 0x38, 0x08, 0x9e, 0x03, 0xc3, 0xf0),
      simde_mm_set_epi8(0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff,
			0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0xff, 0x00) },
    { simde_mm_set_epi8(0x18, 0x1c, 0xa6, 0x24, 0xbd, 0xba, 0x18, 0xe3,
			0xb6, 0x46, 0x84, 0x74, 0xb0, 0x8c, 0xcb, 0x11),
      simde_mm_set_epi8(0x18, 0xd6, 0x8c, 0xd2, 0xbd, 0x35, 0x18, 0xd2,
			0x7e, 0x30, 0x84, 0xda, 0xb0, 0x8c, 0x24, 0x8f),
      simde_mm_set_epi8(0x00, 0xff, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff) },
    { simde_mm_set_epi8(0x83, 0x85, 0x0f, 0xeb, 0x54, 0xf4, 0x92, 0x80,
			0x8c, 0x40, 0x58, 0x49, 0x75, 0xbb, 0x6e, 0x2b),
      simde_mm_set_epi8(0x83, 0x85, 0x58, 0xeb, 0xcf, 0xa9, 0x92, 0x80,
			0x67, 0x17, 0x09, 0x49, 0x1c, 0xbb, 0x6e, 0x47),
      simde_mm_set_epi8(0x00, 0x00, 0xff, 0x00, 0xff, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff) }
  };

  /* for (size_t i = 0 ; i < (sizeof(test_vec) / sizeof(test_vec[0])); i++) { */
  /*   simde__m128i a, b, r; */

  /*   munit_rand_memory(sizeof(a), (uint8_t*) &a); */
  /*   for (size_t j = 0 ; j < sizeof(b.u8) / sizeof(b.u8[0]) ; j++) { */
  /*     b.u8[j] = munit_rand_int_range(0, 1) ? munit_rand_int_range(0, 0xff) : a.u8[j]; */
  /*   } */

  /*   r = simde_mm_cmplt_epi8(a, b); */

  /*   printf("{ simde_mm_set_epi8(0x%02hhx, 0x%02hhx, 0x%02hhx, 0x%02hhx, 0x%02hhx, 0x%02hhx, 0x%02hhx, 0x%02hhx,\n", */
  /* 	   a.u8[7], a.u8[6], a.u8[5], a.u8[4], a.u8[3], a.u8[2], a.u8[1], a.u8[0]); */
  /*   printf("                    0x%02hhx, 0x%02hhx, 0x%02hhx, 0x%02hhx, 0x%02hhx, 0x%02hhx, 0x%02hhx, 0x%02hhx),\n", */
  /* 	   a.u8[15], a.u8[14], a.u8[13], a.u8[12], a.u8[11], a.u8[10], a.u8[9], a.u8[8]); */
  /*   printf("  simde_mm_set_epi8(0x%02hhx, 0x%02hhx, 0x%02hhx, 0x%02hhx, 0x%02hhx, 0x%02hhx, 0x%02hhx, 0x%02hhx,\n", */
  /* 	   b.u8[7], b.u8[6], b.u8[5], b.u8[4], b.u8[3], b.u8[2], b.u8[1], b.u8[0]); */
  /*   printf("                    0x%02hhx, 0x%02hhx, 0x%02hhx, 0x%02hhx, 0x%02hhx, 0x%02hhx, 0x%02hhx, 0x%02hhx),\n", */
  /* 	   b.u8[15], b.u8[14], b.u8[13], b.u8[12], b.u8[11], b.u8[10], b.u8[9], b.u8[8]); */
  /*   printf("  simde_mm_set_epi8(0x%02hhx, 0x%02hhx, 0x%02hhx, 0x%02hhx, 0x%02hhx, 0x%02hhx, 0x%02hhx, 0x%02hhx,\n", */
  /* 	   r.u8[7], r.u8[6], r.u8[5], r.u8[4], r.u8[3], r.u8[2], r.u8[1], r.u8[0]); */
  /*   printf("                    0x%02hhx, 0x%02hhx, 0x%02hhx, 0x%02hhx, 0x%02hhx, 0x%02hhx, 0x%02hhx, 0x%02hhx) },\n", */
  /* 	   r.u8[15], r.u8[14], r.u8[13], r.u8[12], r.u8[11], r.u8[10], r.u8[9], r.u8[8]); */
  /* } */
  /* return MUNIT_FAIL; */

  for (size_t i = 0 ; i < (sizeof(test_vec) / sizeof(test_vec[0])); i++) {
    simde__m128i r = simde_mm_cmplt_epi8(test_vec[i].a, test_vec[i].b);
    assert_m128i_epi8(r, ==, test_vec[i].r);
  }

  return MUNIT_OK;
}

static MunitResult
test_simde_mm_set_epi8(const MunitParameter params[], void* data) {
  (void) params;
  (void) data;

  for (size_t i = 0 ; i < 32 ; i++) {
    int8_t a[16];
    simde__m128i r;

    munit_rand_memory(sizeof(a), (uint8_t*) a);
    r = simde_mm_set_epi8(a[15], a[14], a[13], a[12], a[11], a[10], a[ 9], a[ 8],
			  a[ 7], a[ 6], a[ 5], a[ 4], a[ 3], a[ 2], a[ 1], a[ 0]);

    munit_assert_memory_equal(sizeof(a), a, &r);
  }

  return MUNIT_OK;
}

static MunitResult
test_simde_mm_set_epi16(const MunitParameter params[], void* data) {
  (void) params;
  (void) data;

  for (size_t i = 0 ; i < 32 ; i++) {
    int16_t a[8];
    simde__m128i r;

    munit_rand_memory(sizeof(a), (uint8_t*) a);
    r = simde_mm_set_epi16(a[7], a[6], a[5], a[4], a[3], a[2], a[1], a[0]);

    munit_assert_memory_equal(sizeof(a), a, &r);
  }

  return MUNIT_OK;
}

static MunitResult
test_simde_mm_set_epi32(const MunitParameter params[], void* data) {
  (void) params;
  (void) data;

  for (size_t i = 0 ; i < 32 ; i++) {
    int32_t a[4];
    simde__m128i r;

    munit_rand_memory(sizeof(a), (uint8_t*) a);
    r = simde_mm_set_epi32(a[3], a[2], a[1], a[0]);

    munit_assert_memory_equal(sizeof(a), a, &r);
  }

  return MUNIT_OK;
}

static MunitTest test_suite_tests[] = {
  { (char*) "/sse2/mm_set_epi8",     test_simde_mm_set_epi8,      NULL, NULL, MUNIT_TEST_OPTION_NONE, NULL },
  { (char*) "/sse2/mm_set_epi16",    test_simde_mm_set_epi16,     NULL, NULL, MUNIT_TEST_OPTION_NONE, NULL },
  { (char*) "/sse2/mm_set_epi32",    test_simde_mm_set_epi32,     NULL, NULL, MUNIT_TEST_OPTION_NONE, NULL },
  { (char*) "/sse2/mm_add_epi8",     test_simde_mm_add_epi8,      NULL, NULL, MUNIT_TEST_OPTION_NONE, NULL },
  { (char*) "/sse2/mm_andnot_si128", test_simde_mm_andnot_si128,  NULL, NULL, MUNIT_TEST_OPTION_NONE, NULL },
  { (char*) "/sse2/mm_and_si128",    test_simde_mm_and_si128,     NULL, NULL, MUNIT_TEST_OPTION_NONE, NULL },
  { (char*) "/sse2/mm_cmpeq_epi8",   test_simde_mm_cmpeq_epi8,    NULL, NULL, MUNIT_TEST_OPTION_NONE, NULL },
  { (char*) "/sse2/mm_cmplt_epi8",   test_simde_mm_cmplt_epi8,    NULL, NULL, MUNIT_TEST_OPTION_NONE, NULL },

  { NULL, NULL, NULL, NULL, MUNIT_TEST_OPTION_NONE, NULL }
};

const MunitSuite simde_sse2_test_suite = {
  (char*) "/sse2",
  test_suite_tests,
  NULL,
  1,
  MUNIT_SUITE_OPTION_NONE
};
